{"version":3,"file":"react-firestore.umd.min.js","sources":["../../src/Firestore.js","../../src/FirestoreCache.js","../../src/FirestoreProvider.js","../../src/FirestoreCollection.js","../../src/utils/deepEqual.js","../../src/FirestoreDocument.js","../../node_modules/hoist-non-react-statics/index.js","../../src/withFirestore.js"],"sourcesContent":["import { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nclass Firestore extends Component {\n  static propTypes = {\n    render: PropTypes.func.isRequired,\n  };\n\n  static contextTypes = {\n    firestoreDatabase: PropTypes.object.isRequired,\n  };\n\n  render() {\n    const { firestoreDatabase } = this.context;\n    const { render } = this.props;\n\n    return render({ firestore: firestoreDatabase });\n  }\n}\n\nexport default Firestore;\n","export default class FirestoreCache {}\n","import { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport FirestoreCache from './FirestoreCache';\n\nexport default class FirestoreProvider extends Component {\n  static propTypes = {\n    firebase: PropTypes.object.isRequired,\n    children: PropTypes.node.isRequired,\n  };\n\n  static childContextTypes = {\n    firestoreDatabase: PropTypes.object.isRequired,\n    firestoreCache: PropTypes.object.isRequired,\n  };\n\n  constructor(props) {\n    super(props);\n\n    const { firebase } = props;\n\n    this.state = {\n      firestoreDatabase: firebase.firestore(),\n      firestoreCache: new FirestoreCache(),\n    };\n  }\n\n  getChildContext() {\n    const { firestoreDatabase, firestoreCache } = this.state;\n\n    return { firestoreDatabase, firestoreCache };\n  }\n\n  render() {\n    return this.props.children;\n  }\n}\n","import { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport deepEqual from './utils/deepEqual';\n\nclass FirestoreCollection extends Component {\n  static propTypes = {\n    path: PropTypes.string.isRequired,\n    sort: PropTypes.string,\n    limit: PropTypes.number,\n    filter: PropTypes.oneOfType([\n      PropTypes.arrayOf(\n        PropTypes.oneOfType([\n          PropTypes.string,\n          PropTypes.number,\n          PropTypes.object,\n        ]),\n      ),\n      PropTypes.arrayOf(PropTypes.array),\n    ]),\n    children: PropTypes.func,\n    render: PropTypes.func,\n  };\n\n  static contextTypes = {\n    firestoreDatabase: PropTypes.object.isRequired,\n    firestoreCache: PropTypes.object.isRequired,\n  };\n\n  state = {\n    isLoading: true,\n    data: [],\n    snapshot: null,\n  };\n\n  componentDidMount() {\n    this.setupFirestoreListener(this.props);\n  }\n\n  componentWillUnmount() {\n    this.handleUnsubscribe();\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (\n      nextProps.path !== this.props.path ||\n      nextProps.sort !== this.props.sort ||\n      nextProps.limit !== this.props.limit ||\n      !deepEqual(nextProps.filter, this.props.filter)\n    ) {\n      this.handleUnsubscribe();\n\n      this.setState({ isLoading: true }, () =>\n        this.setupFirestoreListener(this.props),\n      );\n    }\n  }\n\n  handleUnsubscribe() {\n    if (this.unsubscribe) {\n      this.unsubscribe();\n    }\n  }\n\n  setupFirestoreListener = props => {\n    const { firestoreDatabase } = this.context;\n    const { path, ...queryProps } = props;\n    const collectionRef = firestoreDatabase.collection(path);\n    const query = this.buildQuery(collectionRef, queryProps);\n\n    this.unsubscribe = query.onSnapshot(snapshot => {\n      if (snapshot) {\n        this.setState({\n          isLoading: false,\n          data: snapshot.docs.map(doc => ({\n            id: doc.id,\n            ...doc.data(),\n          })),\n          snapshot,\n        });\n      }\n    });\n  };\n\n  buildQuery = (collectionRef, queryProps) => {\n    const { sort, limit, filter } = queryProps;\n    let query = collectionRef;\n\n    if (sort) {\n      sort.split(',').forEach(sortItem => {\n        const [field, order] = sortItem.split(':');\n\n        query = query.orderBy(field, order);\n      });\n    }\n\n    if (limit) {\n      query = query.limit(limit);\n    }\n\n    if (filter) {\n      //if filter is array of array, build the compound query\n      if (Array.isArray(filter[0])) {\n        filter.forEach(clause => {\n          query = query.where(...clause);\n        });\n      } else {\n        //build the simple query\n        query = query.where(...filter);\n      }\n    }\n\n    return query;\n  };\n\n  render() {\n    const { children, render } = this.props;\n\n    if (render) return render(this.state);\n\n    if (typeof children === 'function') return children(this.state);\n\n    return null;\n  }\n}\n\nexport default FirestoreCollection;\n","/**\n * Deep equality comparison for Arrays\n * @param {Array} a The array to compare against\n * @param {Array} b The array to compare with\n * @returns {boolean} If the two arrays are equal\n */\nexport default function deepEqual(a, b) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (let i = 0; i < a.length; i++) {\n      if (!deepEqual(a[i], b[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  } else {\n    return a === b;\n  }\n}\n","import { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nclass FirestoreDocument extends Component {\n  static propTypes = {\n    path: PropTypes.string.isRequired,\n    children: PropTypes.func,\n    render: PropTypes.func,\n  };\n\n  static contextTypes = {\n    firestoreDatabase: PropTypes.object.isRequired,\n    firestoreCache: PropTypes.object.isRequired,\n  };\n\n  state = {\n    isLoading: true,\n    data: null,\n    snapshot: null,\n  };\n\n  componentDidMount() {\n    this.setupFirestoreListener(this.props);\n  }\n\n  componentWillUnmount() {\n    this.handleUnsubscribe();\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (nextProps.path !== this.props.path) {\n      this.handleUnsubscribe();\n\n      this.setState({ isLoading: true }, () =>\n        this.setupFirestoreListener(this.props),\n      );\n    }\n  }\n\n  handleUnsubscribe() {\n    if (this.unsubscribe) {\n      this.unsubscribe();\n    }\n  }\n\n  setupFirestoreListener = props => {\n    const { firestoreDatabase } = this.context;\n    const { path } = props;\n    const documentRef = firestoreDatabase.doc(path);\n\n    this.unsubscribe = documentRef.onSnapshot(snapshot => {\n      if (snapshot) {\n        this.setState({\n          isLoading: false,\n          data: {\n            id: snapshot.id,\n            ...snapshot.data(),\n          },\n          snapshot,\n        });\n      }\n    });\n  };\n\n  render() {\n    const { children, render } = this.props;\n\n    if (render) return render(this.state);\n\n    if (typeof children === 'function') return children(this.state);\n\n    return null;\n  }\n}\n\nexport default FirestoreDocument;\n","/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nvar REACT_STATICS = {\n    childContextTypes: true,\n    contextTypes: true,\n    defaultProps: true,\n    displayName: true,\n    getDefaultProps: true,\n    mixins: true,\n    propTypes: true,\n    type: true\n};\n\nvar KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true\n};\n\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = getPrototypeOf && getPrototypeOf(Object);\n\nmodule.exports = function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {\n    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components\n\n        if (objectPrototype) {\n            var inheritedComponent = getPrototypeOf(sourceComponent);\n            if (inheritedComponent && inheritedComponent !== objectPrototype) {\n                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n            }\n        }\n\n        var keys = getOwnPropertyNames(sourceComponent);\n\n        if (getOwnPropertySymbols) {\n            keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n        }\n\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {\n                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n                try { // Avoid failures from read-only properties\n                    defineProperty(targetComponent, key, descriptor);\n                } catch (e) {}\n            }\n        }\n\n        return targetComponent;\n    }\n\n    return targetComponent;\n};\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport hoistStatics from 'hoist-non-react-statics';\nimport Firestore from './Firestore';\n\nconst withFirestore = Component => {\n  const C = props => {\n    const { wrappedComponentRef, ...remainingProps } = props;\n    return (\n      <Firestore\n        render={firestoreComponentProps => (\n          <Component\n            {...remainingProps}\n            {...firestoreComponentProps}\n            ref={wrappedComponentRef}\n          />\n        )}\n      />\n    );\n  };\n\n  C.displayName = `withFirestore(${Component.displayName || Component.name})`;\n  C.WrappedComponent = Component;\n  C.propTypes = {\n    wrappedComponentRef: PropTypes.func,\n  };\n\n  return hoistStatics(C, Component);\n};\n\nexport default withFirestore;\n"],"names":["Firestore","firestoreDatabase","this","context","render","props","firestore","Component","contextTypes","PropTypes","object","isRequired","FirestoreCache","FirestoreProvider","firebase","state","firestoreCache","children","childContextTypes","FirestoreCollection","setupFirestoreListener","_this","path","queryProps","collectionRef","collection","query","buildQuery","unsubscribe","onSnapshot","snapshot","setState","docs","map","doc","id","data","sort","limit","filter","split","forEach","sortItem","field","order","orderBy","Array","isArray","where","clause","handleUnsubscribe","nextProps","deepEqual","a","b","length","i","isLoading","_this2","FirestoreDocument","documentRef","REACT_STATICS","defaultProps","displayName","getDefaultProps","mixins","propTypes","type","KNOWN_STATICS","name","prototype","caller","callee","arguments","arity","defineProperty","Object","getOwnPropertyNames","getOwnPropertySymbols","getOwnPropertyDescriptor","getPrototypeOf","objectPrototype","C","wrappedComponentRef","remainingProps","h","firestoreComponentProps","WrappedComponent","hoistNonReactStatics","targetComponent","sourceComponent","blacklist","inheritedComponent","keys","concat","key","descriptor","e","hoistStatics"],"mappings":"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"}